use udonsharp_core::prelude::*;
use udonsharp_macros::{UdonBehaviour, udon_sync_mode, udon_public, udon_sync, udon_event};
use wasm_bindgen::prelude::*;
use log;

/// Example UdonSharp behaviour demonstrating Rust-to-UdonSharp integration
/// This struct will be compiled to a UdonSharp C# class with all the
/// appropriate attributes and lifecycle methods.
#[derive(UdonBehaviour)]
#[udon_sync_mode("Manual")]
pub struct ExampleBehaviour {
    /// Public field visible in Unity Inspector
    #[udon_public]
    pub message: String,
    
    /// Synchronized field that will be networked to all clients
    #[udon_sync("Continuous")]
    pub counter: i32,
    
    /// Health value with range constraint
    #[udon_public]
    pub health: f32,
    
    /// Private field not visible in inspector
    initialized: bool,
    
    /// Player reference
    local_player: Option<VRCPlayerApi>,
}

// UdonBehaviour implementation will be generated by the derive macro
// Custom lifecycle methods can be implemented here
impl ExampleBehaviour {
    fn custom_start(&mut self) {
        self.message = "Hello from Rust UdonSharp!".to_string();
        self.counter = 0;
        self.health = 100.0;
        self.initialized = true;
        self.local_player = Some(UdonSharpUtility::get_local_player());
        
        log::info!("ExampleBehaviour started with message: {}", self.message);
    }
    
    fn custom_update(&mut self) {
        // Example update logic
        if self.initialized && self.health > 0.0 {
            // Slowly decrease health over time
            self.health -= Time::delta_time() * 0.1;
            if self.health < 0.0 {
                self.health = 0.0;
                self.on_health_depleted();
            }
        }
    }
    
    fn custom_on_player_joined(&mut self, player: VRCPlayerApi) {
        log::info!("Player joined: {}", player.get_display_name());
        self.welcome_player(&player);
    }
    
    fn custom_on_player_left(&mut self, player: VRCPlayerApi) {
        log::info!("Player left: {}", player.get_display_name());
    }
}

impl ExampleBehaviour {
    pub fn new() -> Self {
        Self {
            message: String::new(),
            counter: 0,
            health: 100.0,
            initialized: false,
            local_player: None,
        }
    }
    
    /// Increment the counter and sync to network
    #[udon_event]
    pub fn increment_counter(&mut self) {
        self.counter += 1;
        log::info!("Counter incremented to: {}", self.counter);
        
        // Request serialization to sync the counter value
        // This will be translated to RequestSerialization() in UdonSharp
        self.request_serialization();
    }
    
    /// Reset the counter to zero
    #[udon_event]
    pub fn reset_counter(&mut self) {
        self.counter = 0;
        log::info!("Counter reset to zero");
        self.request_serialization();
    }
    
    /// Heal the player
    #[udon_event]
    pub fn heal_player(&mut self) {
        self.health = (self.health + 25.0).min(100.0);
        log::info!("Player healed! Health: {}", self.health);
    }
    
    /// Network event to broadcast a message to all players
    #[udon_event]
    pub fn broadcast_message(&mut self) {
        let message = format!("Broadcast from {}: Counter is at {}", 
                            self.get_local_player_name(), self.counter);
        
        // This will be translated to SendCustomNetworkEvent in UdonSharp
        UdonSharpUtility::send_custom_network_event(NetworkEventTarget::All, "on_message_received");
    }
    
    /// Handle received network messages
    #[udon_event]
    pub fn on_message_received(&mut self) {
        log::info!("Received network message!");
    }
    
    /// Private helper method
    fn welcome_player(&mut self, player: &VRCPlayerApi) {
        let welcome_msg = format!("Welcome {}! Current counter: {}", 
                                player.get_display_name(), self.counter);
        log::info!("{}", welcome_msg);
    }
    
    /// Handle health depletion
    fn on_health_depleted(&mut self) {
        log::info!("Health depleted! Respawning player...");
        if let Some(ref player) = self.local_player {
            if player.is_local() {
                player.respawn();
            }
        }
    }
    
    /// Get local player name safely
    fn get_local_player_name(&self) -> String {
        self.local_player
            .as_ref()
            .map(|p| p.get_display_name())
            .unwrap_or_else(|| "Unknown".to_string())
    }
    
    /// Request network serialization (will be translated to UdonSharp)
    fn request_serialization(&mut self) {
        // This will be replaced with actual UdonSharp RequestSerialization call
        log::info!("Requesting serialization...");
    }
}

impl UdonSyncable for ExampleBehaviour {
    fn on_deserialization(&mut self) {
        log::info!("Received sync data - Counter: {}, Health: {}", 
                 self.counter, self.health);
    }
    
    fn on_pre_serialization(&mut self) {
        log::info!("Preparing to send sync data...");
    }
    
    fn should_sync(&self) -> bool {
        self.initialized
    }
}

impl VRCEventHandler for ExampleBehaviour {
    fn interact(&mut self) {
        log::info!("Player interacted with object!");
        self.increment_counter();
    }
    
    fn on_trigger_enter(&mut self, _other: Collider) {
        log::info!("Player entered trigger zone");
        self.heal_player();
    }
    
    fn on_trigger_exit(&mut self, _other: Collider) {
        log::info!("Player left trigger zone");
    }
}

impl UIEventHandler for ExampleBehaviour {
    fn on_click(&mut self) {
        log::info!("UI button clicked!");
        self.increment_counter();
    }
    
    fn on_value_changed(&mut self, value: &str) {
        self.message = value.to_string();
        log::info!("Message changed to: {}", self.message);
    }
    
    fn on_slider_changed(&mut self, value: f32) {
        self.health = value * 100.0;
        log::info!("Health set to: {}", self.health);
    }
}

/// Example of a simple utility behaviour
#[derive(UdonBehaviour)]
pub struct UtilityBehaviour {
    #[udon_public]
    pub utility_name: String,
}

// UdonBehaviour implementation will be generated by the derive macro

impl UtilityBehaviour {
    pub fn new() -> Self {
        Self {
            utility_name: String::new(),
        }
    }
    
    #[udon_event]
    pub fn perform_utility_action(&mut self) {
        log::info!("Performing utility action from: {}", self.utility_name);
    }
}

// WASM entry points for the main behaviour
#[wasm_bindgen(start)]
pub fn main() {
    console_error_panic_hook::set_once();
}

#[wasm_bindgen]
pub fn w2us_init() -> *mut ExampleBehaviour {
    Box::into_raw(Box::new(ExampleBehaviour::new()))
}

#[wasm_bindgen]
pub fn w2us_start(behaviour: *mut ExampleBehaviour) {
    unsafe {
        if let Some(behaviour) = behaviour.as_mut() {
            behaviour.start();
        }
    }
}

#[wasm_bindgen]
pub fn w2us_update(behaviour: *mut ExampleBehaviour) {
    unsafe {
        if let Some(behaviour) = behaviour.as_mut() {
            behaviour.update();
        }
    }
}

// Additional WASM entry points for utility behaviour
#[wasm_bindgen]
pub fn w2us_utility_init() -> *mut UtilityBehaviour {
    Box::into_raw(Box::new(UtilityBehaviour::new()))
}

#[wasm_bindgen]
pub fn w2us_utility_start(behaviour: *mut UtilityBehaviour) {
    unsafe {
        if let Some(behaviour) = behaviour.as_mut() {
            behaviour.start();
        }
    }
}