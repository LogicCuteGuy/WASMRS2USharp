use wasm2usharp_enhanced::{
    EnhancedWasm2USharpPipeline, ConversionConfig, 
    FileSplitter, SplittingStrategy,
    CSharpFileGenerator, FileGenerationConfig
};
use std::collections::HashMap;

fn main() -> anyhow::Result<()> {
    // Create a configuration for the conversion
    let config = ConversionConfig {
        class_name: "MyUdonSharpClass".to_string(),
        namespace: Some("MyVRChatWorld".to_string()),
        generate_separate_files: true,
        udonsharp_attributes: true,
        inheritance_support: true,
    };
    
    // Create the enhanced pipeline
    let mut pipeline = EnhancedWasm2USharpPipeline::with_config(config);
    
    // Example WASM bytes (this would normally come from compiling Rust code)
    // For demonstration, we'll use a minimal WASM module
    let wasm_bytes = create_minimal_wasm_module();
    
    // Convert WASM to UdonSharp with OOP analysis
    match pipeline.convert(&wasm_bytes) {
        Ok(result) => {
            println!("Conversion successful!");
            
            // Demonstrate file splitting and generation
            demonstrate_file_splitting_and_generation(&result)?;
            
            println!("\nOOP Analysis Results:");
            println!("- Found {} classes", result.analysis_result.classes.len());
            println!("- Found {} methods", result.analysis_result.methods.len());
            println!("- Found {} inheritance relationships", result.analysis_result.inheritance_relationships.len());
        }
        Err(e) => {
            eprintln!("Conversion failed: {}", e);
        }
    }
    
    Ok(())
}

/// Create a minimal WASM module for demonstration
fn create_minimal_wasm_module() -> Vec<u8> {
    // This is a minimal WASM module that just exports a function
    // In a real scenario, this would be generated by compiling Rust code
    vec![
        0x00, 0x61, 0x73, 0x6d, // WASM magic number
        0x01, 0x00, 0x00, 0x00, // WASM version
        // Type section
        0x01, 0x04, 0x01, 0x60, 0x00, 0x00,
        // Function section  
        0x03, 0x02, 0x01, 0x00,
        // Export section
        0x07, 0x07, 0x01, 0x03, 0x72, 0x75, 0x6e, 0x00, 0x00,
        // Code section
        0x0a, 0x04, 0x01, 0x02, 0x00, 0x0b,
    ]
}
/// Demonstrate file splitting and generation capabilities
fn demonstrate_file_splitting_and_generation(result: &wasm2usharp_enhanced::ConversionResult) -> anyhow::Result<()> {
    println!("\n=== File Splitting and Generation Demo ===");
    
    // Create sample C# code for demonstration
    let sample_code = create_sample_csharp_code();
    
    // Demonstrate different splitting strategies
    demonstrate_splitting_strategies(&sample_code)?;
    
    // Demonstrate file generation with templates
    demonstrate_file_generation()?;
    
    Ok(())
}

/// Demonstrate different file splitting strategies
fn demonstrate_splitting_strategies(code: &str) -> anyhow::Result<()> {
    println!("\n--- File Splitting Strategies ---");
    
    // Strategy 1: Split by class
    println!("\n1. Splitting by Class:");
    let class_splitter = FileSplitter::new(SplittingStrategy::ByClass);
    match class_splitter.split_code(code) {
        Ok(files) => {
            for (filename, file_data) in files {
                println!("  - {}: {} lines", filename, file_data.content.lines().count());
                println!("    Using statements: {:?}", file_data.using_statements);
                if let Some(namespace) = &file_data.namespace {
                    println!("    Namespace: {}", namespace);
                }
            }
        }
        Err(e) => println!("  Error: {}", e),
    }
    
    // Strategy 2: Split by namespace
    println!("\n2. Splitting by Namespace:");
    let namespace_splitter = FileSplitter::new(SplittingStrategy::ByNamespace);
    match namespace_splitter.split_code(code) {
        Ok(files) => {
            for (filename, file_data) in files {
                println!("  - {}: {} lines", filename, file_data.content.lines().count());
            }
        }
        Err(e) => println!("  Error: {}", e),
    }
    
    // Strategy 3: Split by size
    println!("\n3. Splitting by Size (max 1000 chars):");
    let size_splitter = FileSplitter::new(SplittingStrategy::BySize(1000));
    match size_splitter.split_code(code) {
        Ok(files) => {
            for (filename, file_data) in files {
                println!("  - {}: {} chars", filename, file_data.content.len());
            }
        }
        Err(e) => println!("  Error: {}", e),
    }
    
    Ok(())
}

/// Demonstrate file generation with templates
fn demonstrate_file_generation() -> anyhow::Result<()> {
    println!("\n--- File Generation with Templates ---");
    
    // Create a file generator with custom configuration
    let config = FileGenerationConfig {
        include_header_comment: true,
        normalize_line_endings: true,
        trim_trailing_whitespace: true,
        ensure_final_newline: true,
        default_base_class_for_udonsharp: true,
        auto_add_udonsharp_attributes: true,
        organize_using_statements: true,
    };
    
    let generator = CSharpFileGenerator::with_config(config);
    
    // Create sample file data
    let sample_file = wasm2usharp_enhanced::CSharpFile {
        name: "PlayerController.cs".to_string(),
        content: create_sample_class_content(),
        using_statements: vec![
            "UnityEngine".to_string(),
            "VRC.SDKBase".to_string(),
            "VRC.Udon".to_string(),
            "UdonSharp".to_string(),
            "System.Collections.Generic".to_string(),
        ],
        namespace: Some("MyVRChatWorld".to_string()),
        dependencies: ["VRCPlayerApi".to_string(), "GameObject".to_string()].iter().cloned().collect(),
    };
    
    // Generate the file
    match generator.generate_file(&sample_file) {
        Ok(generated_file) => {
            println!("\nGenerated file: {}", generated_file.name);
            println!("Lines: {}", generated_file.metadata.line_count);
            println!("Characters: {}", generated_file.metadata.character_count);
            println!("Generated at: {}", generated_file.metadata.generated_at);
            println!("\nContent preview (first 20 lines):");
            for (i, line) in generated_file.content.lines().take(20).enumerate() {
                println!("{:3}: {}", i + 1, line);
            }
            if generated_file.content.lines().count() > 20 {
                println!("... ({} more lines)", generated_file.content.lines().count() - 20);
            }
        }
        Err(e) => println!("Generation failed: {}", e),
    }
    
    Ok(())
}

/// Create sample C# code for demonstration
fn create_sample_csharp_code() -> String {
    r#"
using UnityEngine;
using VRC.SDKBase;
using VRC.Udon;
using UdonSharp;
using System.Collections.Generic;

namespace MyVRChatWorld
{
    [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
    public class PlayerController : UdonSharpBehaviour
    {
        [UdonSynced]
        public string playerName;
        
        [UdonSynced]
        public Vector3 spawnPosition;
        
        private List<VRCPlayerApi> connectedPlayers;
        
        public void Start()
        {
            connectedPlayers = new List<VRCPlayerApi>();
            spawnPosition = transform.position;
        }
        
        public void Update()
        {
            // Update logic here
        }
        
        public override void OnPlayerJoined(VRCPlayerApi player)
        {
            connectedPlayers.Add(player);
            SendCustomNetworkEvent(NetworkEventTarget.All, "UpdatePlayerCount");
        }
        
        public void UpdatePlayerCount()
        {
            // Update player count display
        }
    }
    
    [UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
    public class WorldManager : UdonSharpBehaviour
    {
        [UdonSynced]
        public bool worldActive;
        
        public PlayerController playerController;
        
        public void Start()
        {
            worldActive = true;
        }
        
        public void ToggleWorld()
        {
            worldActive = !worldActive;
            SendCustomNetworkEvent(NetworkEventTarget.All, "OnWorldToggled");
        }
        
        public void OnWorldToggled()
        {
            // Handle world toggle
        }
    }
}

namespace MyVRChatWorld.Utilities
{
    public static class MathUtils
    {
        public static float Lerp(float a, float b, float t)
        {
            return a + (b - a) * t;
        }
        
        public static Vector3 RandomPosition(Vector3 center, float radius)
        {
            Vector3 randomDir = Random.insideUnitSphere * radius;
            return center + randomDir;
        }
    }
}
"#.to_string()
}

/// Create sample class content for file generation
fn create_sample_class_content() -> String {
    r#"[UdonBehaviourSyncMode(BehaviourSyncMode.Manual)]
public class PlayerController : UdonSharpBehaviour
{
    [UdonSynced]
    public string playerName;
    
    [UdonSynced]
    public Vector3 spawnPosition;
    
    private List<VRCPlayerApi> connectedPlayers;
    
    public void Start()
    {
        connectedPlayers = new List<VRCPlayerApi>();
        spawnPosition = transform.position;
    }
    
    public void Update()
    {
        // Update logic here
    }
    
    public override void OnPlayerJoined(VRCPlayerApi player)
    {
        connectedPlayers.Add(player);
        SendCustomNetworkEvent(NetworkEventTarget.All, "UpdatePlayerCount");
    }
    
    public void UpdatePlayerCount()
    {
        // Update player count display
    }
}"#.to_string()
}