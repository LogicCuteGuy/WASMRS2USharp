//! Debug information generator for standard multi-behavior pattern
//! 
//! This module generates debugging information in the generated C# code to help
//! developers trace back to the original Rust source and understand the
//! compilation process.

use crate::multi_behavior::{UdonBehaviourStruct, StructField, StructMethod};
use std::collections::HashMap;

/// Generates debug information for C# code
pub struct DebugInfoGenerator {
    /// Whether to include debug information
    include_debug_info: bool,
    /// Source file mapping for line numbers
    source_mapping: HashMap<String, SourceLocation>,
    /// Compilation timestamp
    compilation_timestamp: String,
}

/// Source location information
#[derive(Debug, Clone)]
pub struct SourceLocation {
    pub file_path: String,
    pub line_number: usize,
    pub column_number: usize,
}

/// Debug information for a generated C# element
#[derive(Debug, Clone)]
pub struct DebugInfo {
    pub rust_source_location: Option<SourceLocation>,
    pub original_rust_name: String,
    pub compilation_notes: Vec<String>,
    pub performance_hints: Vec<String>,
}

impl DebugInfoGenerator {
    /// Create a new debug info generator
    pub fn new(include_debug_info: bool) -> Self {
        Self {
            include_debug_info,
            source_mapping: HashMap::new(),
            compilation_timestamp: chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC").to_string(),
        }
    }

    /// Add source mapping information
    pub fn add_source_mapping(&mut self, rust_name: String, location: SourceLocation) {
        self.source_mapping.insert(rust_name, location);
    }

    /// Generate debug header for a C# file
    pub fn generate_file_header(&self, behavior_name: &str, original_rust_file: &str) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        format!(
            r#"//
// Generated by UdonSharp-Rust Compiler
// Compilation Time: {}
// Original Rust File: {}
// Behavior: {}
// 
// This file was automatically generated from Rust source code.
// Do not modify this file directly - changes will be lost on recompilation.
// To make changes, edit the original Rust source file and recompile.
//
// Standard Multi-Behavior Pattern: This behavior is part of a multi-behavior system.
// See the SharedRuntime class for shared functionality across behaviors.
//

"#,
            self.compilation_timestamp, original_rust_file, behavior_name
        )
    }

    /// Generate debug comment for a struct field
    pub fn generate_field_debug_comment(&self, field: &StructField) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        let mut comment = format!("    // Rust field: {}\n", field.name);
        
        if let Some(location) = self.source_mapping.get(&field.name) {
            comment.push_str(&format!(
                "    // Source: {}:{}\n",
                location.file_path, location.line_number
            ));
        }

        // Add type information
        comment.push_str(&format!("    // Original type: {:?}\n", field.field_type));

        // Add attribute information
        if !field.attributes.is_empty() {
            comment.push_str("    // Attributes: ");
            for (i, attr) in field.attributes.iter().enumerate() {
                if i > 0 {
                    comment.push_str(", ");
                }
                comment.push_str(&format!("{:?}", attr));
            }
            comment.push('\n');
        }

        comment
    }

    /// Generate debug comment for a struct method
    pub fn generate_method_debug_comment(&self, method: &StructMethod) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        let mut comment = format!("    // Rust method: {}\n", method.name);
        
        if let Some(location) = self.source_mapping.get(&method.name) {
            comment.push_str(&format!(
                "    // Source: {}:{}\n",
                location.file_path, location.line_number
            ));
        }

        // Add method signature information
        comment.push_str(&format!("    // Return type: {:?}\n", method.return_type));
        
        if !method.parameters.is_empty() {
            comment.push_str("    // Parameters: ");
            for (i, param) in method.parameters.iter().enumerate() {
                if i > 0 {
                    comment.push_str(", ");
                }
                comment.push_str(&format!("{}: {:?}", param.name, param.param_type));
            }
            comment.push('\n');
        }

        // Add Unity event information
        if method.is_unity_event() {
            comment.push_str("    // Unity Event Method\n");
        }

        // Add custom event information
        if method.is_custom_event() {
            comment.push_str("    // Custom Event Handler\n");
        }

        comment
    }

    /// Generate debug comment for SharedRuntime functions
    pub fn generate_shared_function_debug_comment(&self, function_name: &str, used_by: &[String]) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        let mut comment = format!("    // Shared function: {}\n", function_name);
        
        if let Some(location) = self.source_mapping.get(function_name) {
            comment.push_str(&format!(
                "    // Source: {}:{}\n",
                location.file_path, location.line_number
            ));
        }

        comment.push_str(&format!("    // Used by {} behaviors: {}\n", 
            used_by.len(), 
            used_by.join(", ")
        ));

        comment
    }

    /// Generate compilation report comment
    pub fn generate_compilation_report(&self, 
        total_behaviors: usize,
        total_shared_functions: usize,
        inter_behavior_calls: usize
    ) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        format!(
            r#"//
// === Compilation Report ===
// Total Behaviors: {}
// Shared Functions: {}
// Inter-Behavior Calls: {}
// Compilation Time: {}
//
// This report provides information about the multi-behavior compilation process.
// Use this information for debugging and performance optimization.
//
"#,
            total_behaviors,
            total_shared_functions,
            inter_behavior_calls,
            self.compilation_timestamp
        )
    }

    /// Generate performance hints for a behavior
    pub fn generate_performance_hints(&self, behavior: &UdonBehaviourStruct) -> Vec<String> {
        let mut hints = Vec::new();

        // Check for potential performance issues
        let sync_field_count = behavior.get_sync_fields().len();
        if sync_field_count > 10 {
            hints.push(format!(
                "Consider reducing synchronized fields ({}). Too many sync fields can impact network performance.",
                sync_field_count
            ));
        }

        // Check for complex types
        for field in &behavior.fields {
            if !field.field_type.is_udonsharp_compatible() {
                hints.push(format!(
                    "Field '{}' uses type '{:?}' which may have limited UdonSharp support.",
                    field.name, field.field_type
                ));
            }
        }

        // Check for update method
        let has_update = behavior.methods.iter().any(|m| m.name == "update");
        if has_update {
            hints.push(
                "Behavior has Update method. Ensure it's optimized for per-frame execution.".to_string()
            );
        }

        hints
    }

    /// Generate debugging utilities for a behavior
    pub fn generate_debug_utilities(&self, behavior_name: &str) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        format!(
            r#"
    #if UNITY_EDITOR
    /// Debug utility methods (only available in editor)
    
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    private void LogDebugInfo(string message)
    {{
        Debug.Log($"[{0}] {{message}}", "{1}");
    }}
    
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    private void LogWarning(string message)
    {{
        Debug.LogWarning($"[{0}] {{message}}", "{1}");
    }}
    
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    private void LogError(string message)
    {{
        Debug.LogError($"[{0}] {{message}}", "{1}");
    }}
    
    /// Validate behavior state (editor only)
    [System.Diagnostics.Conditional("UNITY_EDITOR")]
    private void ValidateBehaviorState()
    {{
        // Add validation logic here
        LogDebugInfo("Behavior state validation completed");
    }}
    #endif
"#,
            behavior_name, behavior_name
        )
    }

    /// Generate dependency visualization comment
    pub fn generate_dependency_visualization(&self, 
        behavior_name: &str, 
        dependencies: &[String],
        dependents: &[String]
    ) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        let mut comment = format!("// === Dependency Graph for {} ===\n", behavior_name);
        
        if !dependencies.is_empty() {
            comment.push_str("// Dependencies (this behavior depends on):\n");
            for dep in dependencies {
                comment.push_str(&format!("//   -> {}\n", dep));
            }
        }
        
        if !dependents.is_empty() {
            comment.push_str("// Dependents (behaviors that depend on this):\n");
            for dep in dependents {
                comment.push_str(&format!("//   <- {}\n", dep));
            }
        }
        
        if dependencies.is_empty() && dependents.is_empty() {
            comment.push_str("// No dependencies (standalone behavior)\n");
        }
        
        comment.push_str("//\n");
        comment
    }

    /// Generate event flow documentation
    pub fn generate_event_flow_documentation(&self, behavior: &UdonBehaviourStruct) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        let mut doc = String::from("// === Event Flow Documentation ===\n");
        
        // Unity events
        let unity_events: Vec<_> = behavior.methods.iter()
            .filter(|m| m.is_unity_event())
            .collect();
        
        if !unity_events.is_empty() {
            doc.push_str("// Unity Events:\n");
            for event in unity_events {
                doc.push_str(&format!("//   {} - Unity lifecycle event\n", event.name));
            }
        }
        
        // Custom events
        let custom_events: Vec<_> = behavior.methods.iter()
            .filter(|m| m.is_custom_event())
            .collect();
        
        if !custom_events.is_empty() {
            doc.push_str("// Custom Events:\n");
            for event in custom_events {
                doc.push_str(&format!("//   {} - Custom event handler\n", event.name));
            }
        }
        
        doc.push_str("//\n");
        doc
    }

    /// Generate code generation metadata
    pub fn generate_code_generation_metadata(&self, 
        behavior: &UdonBehaviourStruct,
        generation_stats: &CodeGenerationStats
    ) -> String {
        if !self.include_debug_info {
            return String::new();
        }

        format!(
            r#"//
// === Code Generation Metadata ===
// Behavior: {}
// Fields Generated: {}
// Methods Generated: {}
// Custom Events: {}
// Unity Events: {}
// Synchronized Fields: {}
// GameObject References: {}
// Generation Time: {}ms
//
"#,
            behavior.name,
            generation_stats.fields_generated,
            generation_stats.methods_generated,
            generation_stats.custom_events_generated,
            generation_stats.unity_events_generated,
            generation_stats.sync_fields_generated,
            generation_stats.gameobject_references_generated,
            generation_stats.generation_time_ms
        )
    }
}

/// Statistics about code generation
#[derive(Debug, Clone)]
pub struct CodeGenerationStats {
    pub fields_generated: usize,
    pub methods_generated: usize,
    pub custom_events_generated: usize,
    pub unity_events_generated: usize,
    pub sync_fields_generated: usize,
    pub gameobject_references_generated: usize,
    pub generation_time_ms: u64,
}

impl CodeGenerationStats {
    /// Create new generation stats
    pub fn new() -> Self {
        Self {
            fields_generated: 0,
            methods_generated: 0,
            custom_events_generated: 0,
            unity_events_generated: 0,
            sync_fields_generated: 0,
            gameobject_references_generated: 0,
            generation_time_ms: 0,
        }
    }

    /// Calculate stats from a behavior
    pub fn from_behavior(behavior: &UdonBehaviourStruct, generation_time_ms: u64) -> Self {
        Self {
            fields_generated: behavior.fields.len(),
            methods_generated: behavior.methods.len(),
            custom_events_generated: behavior.methods.iter().filter(|m| m.is_custom_event()).count(),
            unity_events_generated: behavior.methods.iter().filter(|m| m.is_unity_event()).count(),
            sync_fields_generated: behavior.get_sync_fields().len(),
            gameobject_references_generated: behavior.fields.iter()
                .filter(|f| matches!(f.field_type, crate::multi_behavior::RustType::GameObject | 
                    crate::multi_behavior::RustType::Option(ref inner) if matches!(**inner, crate::multi_behavior::RustType::GameObject)))
                .count(),
            generation_time_ms,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::multi_behavior::{UdonBehaviourStruct, StructField, RustType, FieldAttribute};

    #[test]
    fn test_debug_info_generator_creation() {
        let generator = DebugInfoGenerator::new(true);
        assert!(generator.include_debug_info);
    }

    #[test]
    fn test_file_header_generation() {
        let generator = DebugInfoGenerator::new(true);
        let header = generator.generate_file_header("TestBehavior", "src/lib.rs");
        
        assert!(header.contains("Generated by UdonSharp-Rust Compiler"));
        assert!(header.contains("TestBehavior"));
        assert!(header.contains("src/lib.rs"));
    }

    #[test]
    fn test_field_debug_comment() {
        let generator = DebugInfoGenerator::new(true);
        let mut field = StructField::new("test_field".to_string(), RustType::I32);
        field.add_attribute(FieldAttribute::UdonPublic);
        
        let comment = generator.generate_field_debug_comment(&field);
        
        assert!(comment.contains("Rust field: test_field"));
        assert!(comment.contains("Original type: I32"));
        assert!(comment.contains("UdonPublic"));
    }

    #[test]
    fn test_performance_hints() {
        let generator = DebugInfoGenerator::new(true);
        let mut behavior = UdonBehaviourStruct::new("TestBehavior".to_string());
        
        // Add many sync fields to trigger performance hint
        for i in 0..15 {
            let mut field = StructField::new(format!("sync_field_{}", i), RustType::I32);
            field.add_attribute(FieldAttribute::UdonSync);
            behavior.add_field(field);
        }
        
        let hints = generator.generate_performance_hints(&behavior);
        assert!(!hints.is_empty());
        assert!(hints.iter().any(|h| h.contains("synchronized fields")));
    }

    #[test]
    fn test_code_generation_stats() {
        let mut behavior = UdonBehaviourStruct::new("TestBehavior".to_string());
        
        // Add some fields and methods
        behavior.add_field(StructField::new("field1".to_string(), RustType::I32));
        behavior.add_field(StructField::new("field2".to_string(), RustType::GameObject));
        
        let stats = CodeGenerationStats::from_behavior(&behavior, 100);
        
        assert_eq!(stats.fields_generated, 2);
        assert_eq!(stats.gameobject_references_generated, 1);
        assert_eq!(stats.generation_time_ms, 100);
    }
}